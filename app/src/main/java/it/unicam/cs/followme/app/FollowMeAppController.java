package it.unicam.cs.followme.app;

import it.unicam.cs.followme.Referee;
import it.unicam.cs.followme.model.Robot;
import it.unicam.cs.followme.utilities.FollowMeParserException;
import it.unicam.cs.followme.utilities.ShapeData;
import javafx.application.Platform;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.*;
import javafx.scene.layout.AnchorPane;
import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.stage.FileChooser;
import javafx.stage.Stage;

import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Optional;

/**
 * JavaFX Controller of FollowMeApp.
 */
public class FollowMeAppController {
    public static final int WIDTH = 600;
    public static final int HEIGHT = 700;

    @FXML
    private Button loadEnvironmentButton;
    @FXML
    private Button executeButton;
    @FXML
    private Button restartButton;
    @FXML
    private Label timeExecutionLabel;
    @FXML
    private AnchorPane anchorPane;
    @FXML
    private Canvas drawArea;

    private Referee referee;
    private int timeOfRefresh;

    /**
     * Initializes the controller. This method is invoked by JavaFX.
     * It initializes the application and prompts the user for initial input.
     */
    public void initialize() {
        try {
            int numberOfRobots = this.openTextInputDialog("Robots Generator",
                    "Enter the number of robots you want to generate:");
            this.timeOfRefresh = this.openChoicesInputDialog("Time for Instruction",
                    "Enter the time of each instruction:");
            this.referee = new Referee(numberOfRobots, this.drawArea.getWidth(), this.drawArea.getHeight(),
                    this.timeOfRefresh);
            this.drawRobots(this.referee.getInitSwarm(), Color.GRAY);
        } catch (IllegalArgumentException e) {
            this.errorAlert(e.getMessage());
            this.initialize();
        }
    }

    /**
     * Handles the action of loading the environment.
     *
     * @param actionEvent The action event generated by the button.
     */
    public void loadEnvironment(ActionEvent actionEvent) {
        try {
            this.referee.compileEnvironment(this.loadFile(actionEvent, "Open Environment File",
                    "file Environment", "*.rshp" ));
            this.drawShapes(Referee.getShapes());
            this.loadEnvironmentButton.setDisable(true);
        } catch (FollowMeParserException e) {
            this.errorAlert(e.getMessage());
        } catch (IOException e) {
            this.errorAlert(e.getMessage());
        }
    }

    /**
     * Handles the action of executing the application.
     *
     * @param actionEvent The action event generated by the button.
     */
    public void execute(ActionEvent actionEvent) {
        try {
            long startTime = System.currentTimeMillis();
            this.timeExecutionLabel.setText("0");
            this.referee.compileProgram(this.loadFile(actionEvent, "Open Program File",
                    "file Robot Program", "*.rprg"));
            this.drawRobots(this.referee.getExecutor().getSwarm(), Color.BLACK);
            this.timeExecutionLabel.setText(String.valueOf((System.currentTimeMillis() - startTime) / 1000) +
                    " seconds");
            this.executeButton.setDisable(true);
            this.loadEnvironmentButton.setDisable(true);
        } catch (FollowMeParserException e) {
            this.errorAlert(e.getMessage());
        } catch (IOException e) {
            this.errorAlert(e.getMessage());
        }
    }

    /**
     * Handles the action of restarting the application.
     *
     */
    public void restart() {
        Stage stage = (Stage) this.restartButton.getScene().getWindow();
        stage.close();
        Platform.runLater(() -> {
            try {
                new App().start(new Stage());
            } catch (Exception e) {
                this.errorAlert(e.getMessage());
            }
        });
    }

    /**
     * Loads a file using a FileChooser dialog.
     *
     * @param actionEvent The action event generated by the button.
     * @param title       The title of the file chooser dialog.
     * @param typeFile    The type of file being loaded (e.g., "file Environment").
     * @param extension   The allowed file extension (e.g., "*.rshp").
     * @return The selected File object.
     */
    private File loadFile(ActionEvent actionEvent, String title, String typeFile, String extension) {
        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle(title);
        fileChooser.getExtensionFilters().add(
                new FileChooser.ExtensionFilter(typeFile, extension));
        return fileChooser.showOpenDialog(((Node) actionEvent.getSource()).getScene().getWindow());
    }

    /**
     * Opens an input dialog to get an integer value from the user.
     *
     * @param title      The title of the input dialog.
     * @param headerText The header text of the input dialog.
     * @return The integer value entered by the user.
     */
    private int openTextInputDialog(String title, String headerText) {
        TextInputDialog dialog = new TextInputDialog();
        dialog.setTitle(title);
        dialog.setHeaderText(headerText);
        return Integer.parseInt(dialog.showAndWait().get());
    }

    /**
     * Opens a choice input dialog to allow the user to select a time interval and returns the corresponding value in
     * milliseconds.
     *
     * @param title      The title of the choice input dialog.
     * @param headerText The header text of the choice input dialog.
     * @return The integer value representing the selected time interval in milliseconds.
     *         Returns 0 if the user's selection is not recognized or if no selection is made.
     */
    private int openChoicesInputDialog(String title, String headerText) {
        List<String> choices = List.of("0.5 seconds", "1.0 seconds", "1.5 seconds", "2.0 seconds");
        ChoiceDialog<String> dialog = new ChoiceDialog<>(choices.get(0), choices);
        dialog.setTitle(title);
        dialog.setHeaderText(headerText);
        return switch(dialog.showAndWait().get()) {
            case "0.5 seconds" -> 500;
            case "1.0 seconds"-> 1000;
            case "1.5 seconds"-> 1500;
            case "2.0 seconds"-> 2000;
            default -> 0;
        };
    }

    /**
     * Displays an error alert dialog.
     *
     * @param headerText The header text of the error alert.
     */
    private void errorAlert(String headerText) {
        Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle("Error...");
        alert.setHeaderText(headerText);
        alert.showAndWait();
    }

    /**
     * Draws robots on the canvas.
     *
     * @param swarm The list of Robot objects to be drawn.
     */
    private void drawRobots(List<Robot> swarm, Paint p) {
        GraphicsContext gc = drawArea.getGraphicsContext2D();
        gc.setFill(p);
        swarm.forEach(robot -> gc.fillOval(this.normalizeX(robot.getActualPosition().x()), this.normalizeY(robot
                .getActualPosition().y()), 5, 5));
    }

    /**
     * Draws shapes on the canvas.
     *
     * @param shapes The list of ShapeData objects to be drawn.
     */
    private void drawShapes(List<ShapeData> shapes) {
        GraphicsContext gc = drawArea.getGraphicsContext2D();
        gc.setFont(Font.font("Arial", FontWeight.BOLD, 12));
        shapes.forEach(shapeData -> this.drawShape(shapeData, gc));
    }

    /**
     * Draws a single shape on the canvas.
     *
     * @param shape The ShapeData object to be drawn.
     * @param gc    The GraphicsContext for drawing on the canvas.
     */
    private void drawShape(ShapeData shape, GraphicsContext gc) {
        double[] args = shape.args();
        gc.setFill(Color.LIGHTBLUE);
        gc.setStroke(Color.BLUE);
        gc.setLineWidth(2.0);
        args[0] = this.normalizeX(args[0]);
        args[1] = this.normalizeY(args[1]);
        if (args.length == 3) {
            gc.fillOval(args[0], args[1], args[2], args[2]);
            gc.strokeOval(args[0], args[1], args[2], args[2]);
        } else {
            gc.fillRect(args[0], args[1], args[2], args[3]);
            gc.strokeRect(args[0], args[1], args[2], args[3]);
        }
        gc.setFill(Color.BLUE);
        gc.fillText(shape.label(), args[0], args[1] - 5);
    }

    /**
     * Normalizes an X coordinate with respect to the drawing area.
     *
     * @param x The X coordinate to normalize.
     * @return The normalized X coordinate within the drawing area.
     */
    private double normalizeX(double x) {
        return this.drawArea.getWidth() / 2 + x;
    }

    /**
     * Normalizes a Y coordinate with respect to the drawing area.
     *
     * @param y The Y coordinate to normalize.
     * @return The normalized Y coordinate within the drawing area.
     */
    private double normalizeY(double y) {
        double value = this.drawArea.getHeight() / 2;
        if (y >= 0) {
            return value - y;
        } else {
            return -(-value + y);
        }
    }
}
